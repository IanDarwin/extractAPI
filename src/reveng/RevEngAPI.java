package reveng;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/** Make up a compilable version of a given Sun or other API, 
 * so developers can compile against it without a licensed copy. In Sun's case,
 * all public API info is public on Sun's web site, so this does not disclose
 * anything that is Sun Confidential.
 * <p>This is a clean-room implementation: I did not look at the code
 * for Sun's javap or any similar tool in preparing this program.
 * XXX TODO:<ul>
 * <li>Collapse common code in printing Constructors and Methods
 * <li>Method printing: add exceptions
 * <li>Arguments: Handle arrays (names begin [L)
 * <li>Use default return types consistently: in return statements
 *		and in assigment to protected final variables.
 * </ul>
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id$
 */
public class RevEngAPI extends APIFormatter {

	public static void main(String[] argv) throws Exception {
		new RevEngAPI().doArgs(argv);
	}

	private final static String PREFIX_ARG = "arg";
	
	/** Make up names like "arg0" "arg1", etc. */
	private String mkName(String name, int number) {
		return new StringBuffer(name).append(number).toString();
	}

	private String className;
	private int classNameOffset;

	/** Generate a .java file for the outline of the given class. */
	public void doClass(Class c) throws IOException {
		className = c.getName();
		// pre-compute offset for stripping package name
		classNameOffset = className.lastIndexOf('.') + 1;

		// Inner class
		if (className.indexOf('$') != -1)
			return;

		// get name, as String, with . changed to /
		String slashName = className.replace('.','/');
		String fileName = slashName + ".java";

		System.out.println(className + " --> " + fileName);

		String dirName = slashName.substring(0, slashName.lastIndexOf("/"));
		new File(dirName).mkdirs();

		// create the file.
		PrintWriter out = new PrintWriter(new FileWriter(fileName));

		out.println("// Generated by RevEngAPI for class " + className);

		// If in a package, say so.
		Package pkg;
		if ((pkg = c.getPackage()) != null) {
			out.println("package " + pkg.getName() + ';');
			out.println();
		}
		// print class header
		int cMods = c.getModifiers();
		printModifiers(cMods, out);
		out.print("class ");
		out.print(trim(c.getName()));
		out.print(' ');
		final Class superclass = c.getSuperclass();
		if (superclass != null) {
			out.print("extends ");
			out.print(superclass.getName());
		}
		out.println(" {");
		
		// print fields
		Field[] flds = c.getDeclaredFields();
		for (int i=0; i< flds.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Fields");
			}
			Field f = flds[i];
			int mods = f.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printModifiers(mods, out);
			final Class<?> type = f.getType();
			printType(out, type);
			out.print(' ');
			out.print(f.getName());
			if (Modifier.isFinal(mods)) {
				try {
					out.print(" = " + f.get(null));
				} catch (Exception ex) {
					out.print("; // " + ex.toString());
				}
			}
			out.println(';');
		}

		// print constructors
		Constructor[] ctors = c.getDeclaredConstructors();
		for (int i=0; i< ctors.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Constructors");
			}
			Constructor constructor = ctors[i];
			int mods = constructor.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printModifiers(mods, out);
			out.print(trim(constructor.getName()));
			printArguments(out, constructor.getParameterTypes());
			out.println(" {");
			out.println("\t}");
		}

		// print methods
		Method[] methods = c.getDeclaredMethods();
		for (int i=0; i< methods.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Methods");
			}
			Method method = methods[i];
			if (method.getName().startsWith("access$"))
				continue;
			int mods = method.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printModifiers(mods, out);
			final Class<?> returnType = method.getReturnType();
			printType(out, returnType);
			out.print(' ');
			out.print(trim(method.getName()));
			printArguments(out, method.getParameterTypes());
			if (Modifier.isAbstract(mods)) {
				out.println(';');
			} else {
				out.println(" {");
				if (!returnType.equals(void.class)) {
					out.println("\treturn " + defaultValue(method.getReturnType()) + ';');
				}
				out.println("\t}");
			}
		}


		// End of this class
		out.println("}");
		//out.flush();
		out.close();
	}

	/**
	 * @param out
	 * @param classes
	 */
	private void printArguments(PrintWriter out, Class[] classes) {
		out.print('(');
		for (int j = 0; j<classes.length; j++) {
			if (j > 0) out.print(", ");
			printType(out, classes[j]);
			out.print(' ');
			out.print(mkName(PREFIX_ARG, j));
		}
		out.print(')');
	}

	/**
	 * @param out
	 * @param returnType
	 */
	private void printType(PrintWriter out, final Class<?> returnType) {
		if (returnType == null) {
			out.println("void /*XXX*/");
		} else if (returnType.isArray()) {
			out.print(returnType.getCanonicalName());
		} else {
			out.print(returnType.getName());
		}
	}

	private String trim(String theName) {
		return theName.startsWith(className) ?
			theName.substring(classNameOffset) : theName;
	}

	private class ModInfo {
		int val;
		String name;
		ModInfo(int v, String n) {
			val = v;
			name = n;
		}
	}

	private ModInfo[] modInfo = {
		new ModInfo(16, "final"),
		new ModInfo(2, "private"),
		new ModInfo(1, "public"),
		new ModInfo(4, "protected"),
		new ModInfo(1024, "abstract"),
		new ModInfo(8, "static"),
		new ModInfo(32, "synchronized"),
		new ModInfo(256, "native"),
		new ModInfo(128, "transient"),
		new ModInfo(64, "volatile"),
		new ModInfo(2048, "strict"),
	};

	private void printModifiers(int mods, PrintWriter out) {
		for (int i=0; i < modInfo.length; i++) {
			if ((mods & modInfo[i].val) == modInfo[i].val) {
				out.print(modInfo[i].name);
				out.print(' ');
			}
		}
	}

	private String defaultValue(Class c) {
		if (c.getName().equals("boolean"))
			return "false";
		if (c.isPrimitive()) {
			return "0";
		}
		return "null";
	}

	public void startFile() {
		// maybe save filename as project name?
	}

	public void endFile() {
		// maybe generate a trivial "build.xml" for Ant to create the jar file?
	}
}
